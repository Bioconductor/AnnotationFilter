---
title: "Facilities for Filtering Bioconductor Annotation Resources"
output:
    BiocStyle::html_document2:
        toc_float: true
vignette: >
    %\VignetteIndexEntry{Facilities for Filtering Bioconductor Annotation resources}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
    %\VignettePackage{AnnotationFilter}
---

```{r style, echo = FALSE, results = 'asis', message=FALSE}
BiocStyle::markdown()
```

**Package**: `r Biocpkg("AnnotationFilter")`<br />
**Authors**: `r packageDescription("AnnotationFilter")[["Author"]] `<br />
**Last modified:** `r file.info("AnnotationFilter.Rmd")$mtime`<br />
**Compiled**: `r date()`


# Introduction

A large variety of annotation resources are available in Bioconductor. Accessing
the full content of these databases or even of single tables is computationally
expensive and in many instances not required, as users may want to extract only
sub-sets of the data e.g. genomic coordinates of a single gene. Filtering
annotation resources before data extraction has a major impact on performance
and increases the usability of such genome-scale databases.

The `r Biocpkg("AnnotationFilter")` package was thus developed to provide basic
filter classes to enable a common filtering framework for Bioconductor
annotation resources. `r Biocpkg("AnnotationFilter")` defines filter classes for
some of the most commonly used features in annotation databases, such as
*symbol* or *genename*. Each filter class is supposed to work on a single
database table column and to facilitate filtering on the provided values. Such
filter classes enable the user to build complex queries to retrieve specific
annotations without the need to know column or table names or the layout of
the underlying databases. While initially being developed to be used in the `r
Biocpkg("Organism.dplyr")` and `r Biocpkg("ensembldb")` packages the filter
classes and the related filtering concept can be easily added in other
annotation packages too.


# Filter classes

All filter classes extend the basic `AnnotationFilter` class and take one or more
*values* and a *condition* to allow filtering on a single database table
column. Based on the type of the input value, filter classes are divided into:

- `CharacterFilter`: takes a `character` value of length >= 1 and supports
  conditions `==`, `!=`, `startsWith` and `endsWith`. An example would be a
  `GeneIdFilter` that allows to filter on gene IDs.

- `IntegerFilter`: takes a single `integer` as input and supports the conditions
  `==`, `!=`, `>`, `<`, `>=` and `<=`. An example would be a `GeneStartFilter`
  that filters results on the (chromosomal) start coordinates of genes.

- `GRangesFilter`: is a special case of a filter, as it takes a `GRanges` as
  `value` and performs the filtering on a combination of columns (i.e. start
  coordinate, end coordinate and sequence name and strand). To be consistent
  with the `findOverlaps` method from the `r Biocpkg("IRanges")` package, the
  constructor of the `GRangesFilter` filter takes a `type` argument to define
  its condition. Supported values are `"any"` (the default) that retrieves all
  entries overlapping the `GRanges`, `"start"` and `"end"` matching all features with the same
  start respectively end coordinate, `"within"` matches all features that are
  *within* the range defined by the `GRanges` and `"equal"` returning features
  that are equal to the `GRanges`.

The names of the filter classes are intuitive, the first part corresponding to
the database column name, any character after a `_` being replaced with a
capital letter, followed by the key word `Filter`. The name of a filter for a
database table column `gene_id` is thus called `GeneIdFilter`. The default
database column for a filter is stored in its `field` slot (accessible *via* the
`field` function).

The `supportedFilters` method can be used to get an overview of all available
filter objects defined in `AnnotationFilter`.

```{r supportedFilters}
library(AnnotationFilter)
supportedFilters()
```

The `AnnotationFilter` package provides only the filter classes but not the
functionality to apply the filtering. Since this is dependent on the underlying
data structure and layout it has to be implemented in each package providing
access to annotation resources.


# Usage

Filters are created *via* their dedicated constructor functions such as the
`GeneIdFilter` function for the `GeneIdFilter` class. Because of this simple
and cheap creation, filter classes are thought to be *read-only* and thus don't
provide *setter* methods to change their slot values. In addition to the
constructor functions, `AnnotationFilter` provides the functionality to
*translate* query expressions into filter classes (see further below for an
example).

Below we create a `SymbolFilter` that could be used to filter an annotation
resource to retrieve all entries associated with the specified symbol value(s).

```{r symbol-filter}
library(AnnotationFilter)

smbl <- SymbolFilter("BCL2")
smbl
```

Such a filter is supposed to be used to retrieve all entries associated to
features with a value in a *symbol* database table column matching the filter's
value `"BCL2"`.

Using the `"startsWith"` condition we could define a filter to retrieve all
entries for genes with a symbol starting with the specified value (e.g. `"BCL2"`
and `"BCL2L11"` for the example below.

```{r symbol-startsWith}
smbl <- SymbolFilter("BCL2", condition = "startsWith")
smbl
```

In addition to the constructor functions, `AnnotationFilter` provides a
functionality to create filter instances in a more natural and intuitive way by
*translating* filter expressions (written as a *formula*, i.e. starting with a
`~`).

```{r convert-expression}
smbl <- AnnotationFilter(~ symbol == "BCL2")
smbl
```

Also combinations of filters are supported. Below we create a
`AnnotationFilterList` containing two filter objects.

```{r convert-multi-expression}
flt <- AnnotationFilter(~ symbol == "BCL2" &
                            tx_biotype == "protein_coding")
flt
```

Note however that translation of nested expressions, such as `(symbol ==
"BCL2L11" & tx_biotype == "nonsense_mediated_decay") | (symbol == "BCL2" &
tx_biotype == "protein_coding")` is (currently) not possible.

Such queries can however be build by nesting `AnnotationFilterList` classes.



# Using `AnnotationFilter` in other packages

The `AnnotationFilter` package does only provide filter classes, but no
filtering functionality. This has to be implemented in the package using the
filters. In this section we show, on the example of the `r Biocpkg("ensembldb")`
package, how `AnnotationFilter` can be used/imported in another package and how
filtering functionality could be implemented. For `ensembldb`,
`AnnotationFilter` objects should be translated into corresponding SQL queries. 

Below we define a method `queryForEnsDb` that returns a string representing the
SQL condition. Before we need to define some helper functions that e.g. quote
character strings.

```{r helpers}
.valueForEnsDb <- function(x) {
    vals <- unique(value(x))
    ## Quote character values.
    if (is(x, "CharacterFilter"))
        vals <- paste0("'",
        (gsub(vals, pattern = "'", replacement = "''")),
        "'")
    ## Combine multiple values.
    if (length(vals) > 1)
        vals <- paste0("(", paste0(vals, collapse = ","), ")")
    ## Process the like/startsWith/endsWith
    if (condition(x) == "startsWith")
        vals <- paste0("'", value(x), "%'")
    if (condition(x) == "endsWith")
        vals <- paste0("'%", value(x), "'")
    return(vals)    
}

## Test it
.valueForEnsDb(SymbolFilter(c("BCL2", "BCL2L11")))
```

In addition we need to convert the `condition` to a SQL condition.

```{r helpers-condition}
.conditionForEnsDb <- function(x) {
    cond <- condition(x)
    if (length(unique(value(x))) > 1) {
        if (cond == "==")
            cond <- "in"
        if (cond == "!=")
            cond <- "not in"
    }
    if (cond == "==")
        cond <- "="
    if (cond %in% c("startsWith", "endsWith"))
        cond <- "like"
    return(cond)
}

## Test
.conditionForEnsDb(SymbolFilter(c("BCL2", "BCL2L11")))

```

Now we define the method that generates the query.

```{r queryForEnsDb-def, results = "hide"}
setGeneric("queryForEnsDb", function(object, ...)
           standardGeneric("queryForEnsDb"))
## Implement for CharacterFilter
setMethod("queryForEnsDb", "CharacterFilter", function(object, ...) {
    paste(field(object), .conditionForEnsDb(object),
          .valueForEnsDb(object))
})

```

The SQL `where` condition for a `SymbolFilter` is thus:

```{r symbol-where}
smbls <- SymbolFilter(c("BCL2", "BCL211"))

paste("where", queryForEnsDb(smbls))
```

Now, this assumes that the database columns are called identically to the
`field` of the `AnnotationFilter`. This is not the case for all columns in an
`EnsDb` database, thus, an additional function would be required here, that
returns the actual database table columns for each `AnnotationFilter`.

To translate combinations of filters we would also have to implement a
`queryForEnsDb` for `AnnoationFilterList` objects.


# Session information

```{r si}
sessionInfo()
```
